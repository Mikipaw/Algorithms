\documentclass[12pt]{extreport}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
%\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\varnothing
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%% Enumerations %%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Rnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

%%%%%%%%%%%%%%%%%%%%% EOF Enumerations %%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}
\definecolor{Gray333}{HTML}{333333}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{prvar}

\def\beforPRskip{
	\bigskip
	%\vspace*{2ex}
}

\def\PRSUBskip{
	\medskip
}


\def\pr{\beforPRskip\noindent\stepcounter{problem}{\bf \theproblem .\;}\setcounter{subproblem}{0}}
\def\pru{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^\circ$\!\!.\;}\setcounter{subproblem}{0}}
\def\prstar{\beforPRskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.}\setcounter{subproblem}{0}\;}
\def\prpfrom[#1]{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0} }
\def\prp{\beforPRskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0} }

\def\prpvar{\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;$\langle${\rm\Rnum{\theprvar}}$\rangle$.}\setcounter{subproblem}{0}\;}
\def\prpv{\beforPRskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0} }
\def\prv{\beforPRskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}.\setcounter{subproblem}{0} }

\def\prpstar{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prdag{\beforPRskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0} }
\def\upr{\beforPRskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem .  }\setcounter{subproblem}{0} }
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\PRSUBskip\noindent\stepcounter{subproblem}{\sf \thesubproblem .} }
\def\prsubr{\PRSUBskip\noindent\stepcounter{subproblem}{\bf \asbuk{subproblem})}\;}
\def\prsubstar{\PRSUBskip\noindent\stepcounter{subproblem}{\rm $\thesubproblem^*$\negthickspace.  } }
\def\prsubrstar{\PRSUBskip\noindent\stepcounter{subproblem}{$\text{\bf \asbuk{subproblem}}^*\mathbf{)}$}\;}

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0}
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0}
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

\DeclareDocumentCommand{\Pr}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf\theproblem
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.}

%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\beforPRskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
	\bigskip
%	\bigskip
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EOF Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%\usepackage{erewhon}
%\usepackage{heuristica}
%\usepackage{gentium}

\usepackage[portrait, top=3cm, bottom=1.5cm, left=3cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{\fontfamily{fca}\selectfont {ФПМИ. Основные алгоритмы 2022} }
%\lhead{ \bf  {ТРЯП. } Семинар 1 }
%\chead{\fontfamily{fca}\selectfont {Вариант 1}}
\rhead{\fontfamily{fca}\selectfont Павлов М.А. Домашнее задание 12}
%\rhead{\small 01.09.2016}
\cfoot{}

\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter {\setcounter{problem}{0}}  }{}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Обозначения и операции %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
                                                                    
\newcommand{\divisible}{\mathop{\raisebox{-2pt}{\vdots}}}           
\let\Om\Omega


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shen Macroses %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\w}[1]{{\hbox{\texttt{#1}}}}


\begin{document}
	

\pr Как модифицировать алгоритм Флойда-Уоршелла?

	Чтобы алгоритм Флойда помимо длин кратчайших путей находил и сами кратчайшие пути, необходимо завести двумерный массив направленных ребер Array[from][to], хранящий в каждой ячейке номер вершины,
	в которую необходимо направиться для нахождения кратчайшего пути из from в to.
	Таким образом, на каждой итерации, если мы находим более короткий путь, мы записываем в ячейку массива номер следующей вершины.

	Соответственно после работы алгоритма мы просто идем по этому массиву, пока не дойдем до финишной вершины.

	Сложность: такая же, как и у алгоритма Флойда -- $\Theta(N^3)$ по времени и по памяти.

	Корректность: действительно, если мы будем запоминать, в какие вершины надо заходить, чтобы пойти по кратчайшему пути, то в результате получим искомый кратчайший путь (если он существует).

\pr Цикл отрицательного веса?

	Поскольку алгоритм Флойда ищет расстояния между любыми двумя вершинами $a, b$, где $a, b \in V$ -- множеству вершин, то мы можем найти
	расстояние от $a$ до самой себя. Если алгоритм выдаст, что $\exists$ такая вершина $a \in V$, что расстояние от $a$ до $a$ отрицательное,
	то тогда в графе обязательно найдется цикл отрицательного веса.

\pr В ориентированном взвешенном графе есть ровно одно ребро ($u \to v$) с отрицательным весом. Описать эффективный алгоритм поиска кратчайшего пути между заданной парой вершин $(a,b)$ "--- вход задачи: матрица весов и вершины $a$ и $b$.

	Сначала проверяем в графе наличие отрицательного цикла (как это делать, было разобрано на прошлой неделе).

	Далее убираем ребро с отрицательным весом и ищем длину кратчайшего пути из $a$ в $b$ по алгоритму Дейкстры.

	Аналогично ищем длины кратчайших путей из $a$ в $u$ и из $v$ в $b$.

	Складываем длины этих двух путей и вычитаем абсолютное значение веса удаленного раннее ребра.

	Сравниваем полученную сумму с длиной пути из $a$ в $b$, найденного ранее.

	Берем легчайший из этих двух путей.

	Сложность алгоритма равна сложности алгоритма Дейскстры, который мы применили 3 раза. То есть $O(V^2)$.

	Корректность: поскольку мы знаем, что алгоритм Дейкстры работает корректно при отсутствии ребер отрицательного веса, а
	в нашем алгоритме мы использовали его исключительно при таких условиях, то мы победили -- алгоритм корректен!

\pr В Главе 2 [ДПВ] (раздел 2.5) приведён алгоритм Штрассена для умножения матриц сложностью $O(n^{\log_2 7})$.

\prsub Объясните почему с его помощью нельзя ускорить алгоритмы поиска транзитивного замыкания (поиска вершин, достижимых из каждой вершины) и поиска кратчайших путей, основанных на быстром возведении в степень до $O(n^{\log_2 7}\log n)$?

	Потому что алгоритм Штрассена ничуть не быстрее наивного алгоритма умножения матриц (а для поиска транзитивного замыкания нужно как раз перемножать матрицы).

	Алгоритм Штрассена использует метод "разделяй и влавствуй", деля большую задачу на несколько подзадач.
	А именно он делит исходную матрицу на 4 одинаковые по размеру матрицы и считает произведения маленьких матриц.

	В результате получается рекурсивный алгоритм сложностью $T(n) = 8T(\frac{n}{2}) + O(n^2)$, что по master-теореме дает нам $\theta(n^3)$ -- такую же сложность, что и у наивного алгоритма умножения матриц.

\smallskip

\noindent\textsl{Указание: булева алгебра $\{ \lor, \land\}$ и тропическая алгебра $\{\min, +\}$ не являются кольцами.} 

\prsub Постройте алгоритм, который на основе алгоритма Штрассена находит матрицу транзитивного замыкания ($a_{ij} = 1$ тогда и только тогда, когда $j$ достижима из $i$) оптимальнее, чем за $O(n^{3}\log n)$ и оцените его сложность.

	На самом деле мы можем ускорить алгоритм Штрассена с помощью небольшого алгебраического трюка, перемножив не 8 подматриц, а 7! (это не факториал, а восклицательный знак)

	Сейчас посмотрим! После умножения матрицы X на матрицу Y получаем результат.

\begin{Vmatrix}
	P_4 + P_5 + P_6 - P_2 & P_1 + P_2 \\
	P_3 + P_4 & P_1 + P_5 - P_3 - P_7
\end{Vmatrix}

где

$P_1 = A(F - H), P_2 = (A + B)H, P_3 = (C + D)E, P_4 = D(G-E)$

$P_5 = (A + D)(E + H), P_6 = (B - D)(G + H), P_7 = (A - C)(E + F)$

В результате формула для вычисления времени работы немного изменилась: $T(n) = 7T(\frac{n}{2}) + O(n^2)$.

По master-теореме получаем время работы алгоритма $\theta(n^{log_2 7})$

\prend   

\pr Предложите $O(|V|+|E|)$ алгоритм, который находит центр дерева (вершину, максимальное расстояние от которой до всех остальных минимально). Докажите его корректность и оцените асимптотику.

	Сначала обходим дерево с помощью DFS. -- сложность $O(|V| + |E|)$

	Удаляем все листья дерева. -- сложность

	Повторяем удаление листьев, пока не останется 1 или 2 вершины.

	Оценка асимптотики: обход дерева стоит $O(|V| + |E|)$, удаление листьев суммарно -- $O(|V)|$. В итоге получаем нужную нам асимптотику $O(|V| + |E|)$

	Корректность: действительно, с каждой иттерацией по удалению листьев мы приближаемся все ближе к центру и когда-нибудь мы обязательно до него дойдем.
	Также стоит отметить, что дерево (по одному из определений) -- это граф, в котором нет циклов, поэтому центральных вершин в дереве не может быть больше чем 2 (АЛКТГ ван лав).

\pr Что такое вершинное покрытие мы знаем благодаря ДиМаСиКу ГуЩиНу. Постройте линейный алгоритм, который находит минимальное (по числу вершин) вершинное покрытие для дерева (вход задачи).

	1. Берем любую вершину $u : u$ находится на расстоянии 1 от одного из листьев.

	2. Добавляем вершину $u$ в решение.

	3. Удаляем все ребра, инцидентные $u$.

	4. Решаем аналогично задачу для дерева с мЕньшим количеством вершин.

	Сложность алгоритма -- линейная, т.к. в худшем случае нам необходимо будет взять в решение $\frac{n}{2}$ вершин (двудольный граф), т.к. у дерева по определению $n - 1$ ребро, а каждая вершина может покрыть два ребра.

	Корректность алгоритма тривиальна и может быть доказана по индукции.

\Pr[null][Шень \textbf{1.3.3}] 
Даны две последовательности $\w{x[1]}\ldots\w{x[n]}$
и~$\w{y[1]}\ldots\w{y[m]}$ целых чисел... Сложность алгоритма $O(nm)$.

	Заведем матрицу $n \times m$ и в ячейку $a_{i, j}$ будем писать максимальное из значений среди ячеек $a_{i, j - 1}$ и $a_{i - 1, j}$.
	В случае, если $a_{i, j} = a_{i - 1, j - 1}$, то максимальное из указанных двух выше значений сравниваем со значением $a_{i - 1, j - 1} + 1$ и присваиваем ячейке $a_{i, j}$ максимальное из них.

	В итоге каждой из диагоналей, параллельных главной, мы сопоставляем сращивание двух последовательностей со сдвигом на некоторое количество символов.
	Максимальный сдвиг будет соответствовать максимальной общей части.

\prend   

\end{document}
  